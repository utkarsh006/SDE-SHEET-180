/* TOPOLOGICAL SORT(DFS)

1. Do Dfs call.
2. Mark the node as visited.
3. Explore the neighbours.
4. If neighbour found, repeat step 1-3.
5. If no neighbour, return from function call and push that node into the stack.
6. Print the stack values.   */

class Solution
{
	public:
	
	void DFS(int node, vector<bool> &visited, stack<int> &st, vector<int> adj[])
	{
	    visited[node]=1;  //mark the node as true
	    
	      //explore the neighbours
	      for(auto neighbour : adj[node])
	      {
	          // if neighbour is not visited then call DFS
	          if(!visited[neighbour])
	          {
	              DFS(neighbour, visited, st, adj);
	          }
	      }
	      
	     st.push(node); // if returning from function call, push that node into the stack
	}
	
	
	vector<int> topoSort(int V, vector<int> adj[]) 
	{
	    vector<bool> visited(V,false);
	    stack<int> st;
	    
	    // call DFS Topological sort for all components
	       for(int i=0; i<V; i++)
	       {
	           if(!visited[i])
	             DFS(i, visited, st, adj);
	       }
	       
	   // answer is now in stack, push it to the vector
	         vector<int>ans;
	         
	         while(!st.empty())
	         {
	             ans.push_back(st.top());
	             st.pop();
	         }
	        
	     return ans;  
	}
};
